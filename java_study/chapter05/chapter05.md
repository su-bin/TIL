## CHAPTER-05-참조-타입
### 데이터 타입 분류
- 기본 타입(원시 타입, primitive type) : 정수, 실수, 문자, 논리 리터럴
> 기본 타입을 이용해서 선언된 변수는 실제 값을 변수 안에 저장한다.
- 참조 타입(reference type) : 배열, 열거, 클래스, 인터페이스  
> 참조 타입을 이용해서 선언된 변수는 메모리의 번지를 값으로 갖는다. (번지를 통해 객체를 참조한다.)
- 변수는 스택영역, 객체는 힙 영역에 생성된다.
### 메모리 사용 영역
![RuntimeDataArea](https://t1.daumcdn.net/cfile/tistory/9951B14C5B8F876001)
#### 메소드(Method) 영역
- 코드에서 사용되는 클래스(~.class)들을 클래스 로더로 읽어 클래스별로 런타임 상수풀(runtime constant pool), 필드(field) 데이터, 메소드(method) 데이터, 메소드 코드, 생성자(constructor) 코드 등을 분류해서 저장한다.
- JVM이 시작할 때 생성되고 모든 스레드가 공유하는 영역이다.
#### 힙(Heap) 영역
- 객체와 배열이 생성되는 영역이다.
- 생성된 객체와 배열은 JVM 스택 영역의 변수나 다른 객체의 필드에서 참조한다.
#### JVM 스택(stack) 영역
- 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 할당된다.
- JVM 스택은 메소드를 호출할 때마다 프레임(Frame)을 추가(push)하고 메소드가 종료되면 해당 프레임을 제거(pop)하는 동작을 수행한다.
### 참조 변수의 ==, != 연산
- 참조 타입 변수들 간의 ==, != 연산은 동일한 객체를 참조하는지, 다른 객체를 참조하는지 알아볼 때 사용된다.
- 참조 타입 변수의 값은 힙 영역의 객체 주소이므로 결국 주소 값을 비교하는 것이 된다.
### null과 NullPointerException
- 참조 타입 변수는 힙 영역의 객체를 참조하지 않는다는 뜻으로 null(널) 값을 가질 수 있다.
- null로 초기화된 참조 변수는 스택 영역에 생성된다.
- NullPointerException : 참조 타입 변수를 잘못 사용하면 발생한다.
### String 타입
~~~java
String name;  
name = "수빈";  
String hobby = "자바";
~~~

- name 변수와 hobby 변수는 스택 영역에 생성되고, "수빈"과 "자바"는 힙 영역에 String 객체로 생성된다.
- 문자열은 String 객체로 생성되고 변수는 String 객체를 참조한다.
- 문자열 리터럴이 동일하다면 String 객체를 공유하도록 되어 있다.
~~~java
String name1 = new String("수빈");  
String nema2 = new String("수빈");
~~~

- new 연산자는 힙 영역에 새로운 객체를 만들 떄 사용하는 연산자로 객체 생성 연산자라고 한다.
- == 연산자는 변수에 저장된 객체 번지가 동일한지를 검사한다.
- equals() 메소드는 원본 문자열과 매개값으로 주어진 비교 문자열이 동일한지 비교한다.
- JVM은 참조되지 않은 객체를 쓰레기 객체로 취급하고 쓰레기 수집기(Gabage Collector)를 구동시켜 메모리에서 자동 제거한다.

### 배열 타입
- 배열은 같은 타입의 데이터를 연속된 공간에 나열시키고, 각 데이터에 인덱스(index)를 부여해 놓은 자료구조이다.
_ 한 번 생성된 배열은 길이를 늘리거나 줄일 수 없다.
#### 배열 선언
> 타입[] 변수;  
> 타입 변수[];

- 배열 변수는 참조 변수에 속한다.
- 배열도 객체이므로 힙 영역에 생성되고 배열 변수는 힙 영역의 객체를 참조하게 된다.
#### 값 목록으로 배열 생성
> 데이터 타입[] 변수 = { 값0, 값1, 값2, 값3, ... };

- 배열 변수를 이미 선언한 후에 다른 실행문에서 중괄호를 사용한 배열 생성은 허용되지 않는다,
#### new 연산자로 배열 생성
> 타입[] 변수 = new 타입[길이];  
>  
> 타입[] 변수 = null;  
> 변수 = new 타입[길이];

- new 연산자로 배열을 처음 생성할 경우, 배열은 자동적으로 기본값으로 초기화된다.

> 변수[인덱스] = 값;

- 배열이 생성되고 나서 새로운 값을 저장하려면 대입 연산자를 사용하면 된다.

#### 배열 길이
- 배열의 길이란 배열에 저장할 수 있는 전체 항목 수를 말한다.
> 배열변수.length;
- 만약 배열의 인덱스를 초과해서 사용하면 ArrayIndexOutOfBoundsException이 발생한다.

#### 커맨드 라인 입력

~~~java
public static void main(String[] args){ ... }
~~~

- "java  클래스"로 프로그램을 실행하면JVM은 길이가 0인 String 배열을 먼저 생성하고 main() 메소드를 호출할 깨 매개값으로 전달한다.

#### 다차원 배열
- 값들이 행과 열로서 구성된 배열을 2차원 배열이라고 한다.
- 자바는 2차원 배열을 중첩 배열 방식으로 구현한다.
~~~java
int[][] scores = new int[2][3];
~~~
![다차원배열](https://t1.daumcdn.net/cfile/tistory/995BC9465B9625272F)

- 일차원 배열이 서로 연결된 구조로 다차원 배열을 구현하기 때문에 수학 행렬 구조가 아닌 계단식 구조를 가질 수 있다
~~~java
int[][] scores = new int[2][];
scores[0] = new int[2];
scores[1] = new int[3];
~~~

#### 객체를 참조하는 배열
- 기본 타입(byte, char, short, int, long, float, double, boolean) 배열은 각 항목에 직접 값을 갖고 있지만, 참조 타입(클래스, 인터페이스) 배열은 각 항목에 객체의 번지를 가지고 있다.
~~~java
String[] strArray = new String[3];
strArray[0] = "java";
strArray[1] = "C++";
strArray[2] = "C#";
~~~
![객체를 참조하는 배열](https://t1.daumcdn.net/cfile/tistory/99624E3D5B974B2232)
- String[] 배열 항목 간에 문자열을 비교하기 위해서는 == 연산자 대신 equals() 메소드를 사용해야 한다.

#### 배열 복사
- 배열은 한 번 생성하면 크기를 변경할 수 없기 때문에 더 많은 저장 공간이 필요하다면 보다 큰 배열을 새로 만들고 이전 배열로부터 항목 값들을 복사해야 한다.
- 배열 간의 항목 값들을 복사하려면 for문을 사용하거나 System.arraycopy() 메소드를 사용하면 된다.
~~~java
System.arraycopy(Object src, int srcPos, Object dest, int destPos, int lengrh);
~~~
- 얕은 복사 (shallow copy) : 이전 항목이 참조하는 객체와 동일한 객체 참조
- 깊은 복사 (deep copy) : 참조하는 객체도 별도로 생성

#### 향상된 for문
- 향상된 for문은 반복 실행을 하기 위해 카운터 변수와 증감식을 사용하지 않는다
- 배열 빛 컬렉션 항목의 개수만큼 반복하고, 자동적으로 for문을 빠져나간다.
~~~java
for ( 타입 변수 : 배열 ) {
    실행문;
}
~~~

### 열거 타입
- 한정된 값만을 갖는 데이터 타입이 열거 타입(enumeration type)이다.
- 열거 타입은 몇 개의 열거 상수(enumeration constant)중에서 하나의 상수를 저장하는 데이터 타입이다.

#### 열거 타입 선언
- 열거 타입 이름으로 소스 파일(.java)을 생성한다.
- 열거 타입 이름은 소스 파일명과 대소문자가 모두 일치해야 한다.
~~~java
public enum Week { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY }
~~~
#### 열거 타입 변수
- 열거 타입도 하나의 데이터 타입이므로 변수를 선언하고 사용해야 한다.
~~~java
Week today;
~~~
- 열거 상수는 단독으로 사용할 수는 없고 반드시 열거타입.열거상수로 사용된다.
~~~java
Week today = Week.SUNDAY;
~~~
- 열거 타입도 참조 타입이다, 열거 상수는 열거 객체로 생성된다.

#### 열거 객체의 메소드
##### name() 메소드
- name() 메소드는 열거 객체가 가지고 있는 문자열을 리턴한다.
##### ordinal() 메소드
- ordinal() 메소드는 전체 열거 객체 중 몇 번째 열거 객체인지 알려준다.
##### compareTo() 메소드
- compareTo() 메소드는 매개값으로 주어진 열거 객체를 기준으로 전후로 몇 번째 위치하는지를 비교한다.
##### valueOf() 메소드
- valueOf() 메소드는 매개값으로 주어지는 문자열과 동일한 문자열을 가지는 열거 객체를 리턴한다.
##### values() 메소드
- values() 메소드는 열거 타입의 모든 열거 객체들을 배열로 만들어 리턴한다.